// Code generated by TestGen. DO NOT EDIT.

package benchtests

import (
	"testing"

	"github.com/go-playground/validator/v10"
)

type ValidGenEmailStringStruct struct {
	Field string `valid:"email"`
}

type ValidatorEmailStringStruct struct {
	Field string `validate:"email"`
}

type ValidGenRequiredStringStruct struct {
	Field string `valid:"required"`
}

type ValidatorRequiredStringStruct struct {
	Field string `validate:"required"`
}

type ValidGenRequiredIntStruct struct {
	Field int `valid:"required"`
}

type ValidatorRequiredIntStruct struct {
	Field int `validate:"required"`
}

type ValidGenRequiredInt8Struct struct {
	Field int8 `valid:"required"`
}

type ValidatorRequiredInt8Struct struct {
	Field int8 `validate:"required"`
}

type ValidGenRequiredInt16Struct struct {
	Field int16 `valid:"required"`
}

type ValidatorRequiredInt16Struct struct {
	Field int16 `validate:"required"`
}

type ValidGenRequiredInt32Struct struct {
	Field int32 `valid:"required"`
}

type ValidatorRequiredInt32Struct struct {
	Field int32 `validate:"required"`
}

type ValidGenRequiredInt64Struct struct {
	Field int64 `valid:"required"`
}

type ValidatorRequiredInt64Struct struct {
	Field int64 `validate:"required"`
}

type ValidGenRequiredUintStruct struct {
	Field uint `valid:"required"`
}

type ValidatorRequiredUintStruct struct {
	Field uint `validate:"required"`
}

type ValidGenRequiredUint8Struct struct {
	Field uint8 `valid:"required"`
}

type ValidatorRequiredUint8Struct struct {
	Field uint8 `validate:"required"`
}

type ValidGenRequiredUint16Struct struct {
	Field uint16 `valid:"required"`
}

type ValidatorRequiredUint16Struct struct {
	Field uint16 `validate:"required"`
}

type ValidGenRequiredUint32Struct struct {
	Field uint32 `valid:"required"`
}

type ValidatorRequiredUint32Struct struct {
	Field uint32 `validate:"required"`
}

type ValidGenRequiredUint64Struct struct {
	Field uint64 `valid:"required"`
}

type ValidatorRequiredUint64Struct struct {
	Field uint64 `validate:"required"`
}

type ValidGenRequiredFloat32Struct struct {
	Field float32 `valid:"required"`
}

type ValidatorRequiredFloat32Struct struct {
	Field float32 `validate:"required"`
}

type ValidGenRequiredFloat64Struct struct {
	Field float64 `valid:"required"`
}

type ValidatorRequiredFloat64Struct struct {
	Field float64 `validate:"required"`
}

type ValidGenRequiredBoolStruct struct {
	Field bool `valid:"required"`
}

type ValidatorRequiredBoolStruct struct {
	Field bool `validate:"required"`
}

type ValidGenRequiredStringSliceStruct struct {
	Field []string `valid:"required"`
}

type ValidatorRequiredStringSliceStruct struct {
	Field []string `validate:"required"`
}

type ValidGenRequiredIntSliceStruct struct {
	Field []int `valid:"required"`
}

type ValidatorRequiredIntSliceStruct struct {
	Field []int `validate:"required"`
}

type ValidGenRequiredInt8SliceStruct struct {
	Field []int8 `valid:"required"`
}

type ValidatorRequiredInt8SliceStruct struct {
	Field []int8 `validate:"required"`
}

type ValidGenRequiredInt16SliceStruct struct {
	Field []int16 `valid:"required"`
}

type ValidatorRequiredInt16SliceStruct struct {
	Field []int16 `validate:"required"`
}

type ValidGenRequiredInt32SliceStruct struct {
	Field []int32 `valid:"required"`
}

type ValidatorRequiredInt32SliceStruct struct {
	Field []int32 `validate:"required"`
}

type ValidGenRequiredInt64SliceStruct struct {
	Field []int64 `valid:"required"`
}

type ValidatorRequiredInt64SliceStruct struct {
	Field []int64 `validate:"required"`
}

type ValidGenRequiredUintSliceStruct struct {
	Field []uint `valid:"required"`
}

type ValidatorRequiredUintSliceStruct struct {
	Field []uint `validate:"required"`
}

type ValidGenRequiredUint8SliceStruct struct {
	Field []uint8 `valid:"required"`
}

type ValidatorRequiredUint8SliceStruct struct {
	Field []uint8 `validate:"required"`
}

type ValidGenRequiredUint16SliceStruct struct {
	Field []uint16 `valid:"required"`
}

type ValidatorRequiredUint16SliceStruct struct {
	Field []uint16 `validate:"required"`
}

type ValidGenRequiredUint32SliceStruct struct {
	Field []uint32 `valid:"required"`
}

type ValidatorRequiredUint32SliceStruct struct {
	Field []uint32 `validate:"required"`
}

type ValidGenRequiredUint64SliceStruct struct {
	Field []uint64 `valid:"required"`
}

type ValidatorRequiredUint64SliceStruct struct {
	Field []uint64 `validate:"required"`
}

type ValidGenRequiredFloat32SliceStruct struct {
	Field []float32 `valid:"required"`
}

type ValidatorRequiredFloat32SliceStruct struct {
	Field []float32 `validate:"required"`
}

type ValidGenRequiredFloat64SliceStruct struct {
	Field []float64 `valid:"required"`
}

type ValidatorRequiredFloat64SliceStruct struct {
	Field []float64 `validate:"required"`
}

type ValidGenRequiredBoolSliceStruct struct {
	Field []bool `valid:"required"`
}

type ValidatorRequiredBoolSliceStruct struct {
	Field []bool `validate:"required"`
}

type ValidGenRequiredStringMapStruct struct {
	Field map[string]string `valid:"required"`
}

type ValidatorRequiredStringMapStruct struct {
	Field map[string]string `validate:"required"`
}

type ValidGenRequiredIntMapStruct struct {
	Field map[int]int `valid:"required"`
}

type ValidatorRequiredIntMapStruct struct {
	Field map[int]int `validate:"required"`
}

type ValidGenRequiredInt8MapStruct struct {
	Field map[int8]int8 `valid:"required"`
}

type ValidatorRequiredInt8MapStruct struct {
	Field map[int8]int8 `validate:"required"`
}

type ValidGenRequiredInt16MapStruct struct {
	Field map[int16]int16 `valid:"required"`
}

type ValidatorRequiredInt16MapStruct struct {
	Field map[int16]int16 `validate:"required"`
}

type ValidGenRequiredInt32MapStruct struct {
	Field map[int32]int32 `valid:"required"`
}

type ValidatorRequiredInt32MapStruct struct {
	Field map[int32]int32 `validate:"required"`
}

type ValidGenRequiredInt64MapStruct struct {
	Field map[int64]int64 `valid:"required"`
}

type ValidatorRequiredInt64MapStruct struct {
	Field map[int64]int64 `validate:"required"`
}

type ValidGenRequiredUintMapStruct struct {
	Field map[uint]uint `valid:"required"`
}

type ValidatorRequiredUintMapStruct struct {
	Field map[uint]uint `validate:"required"`
}

type ValidGenRequiredUint8MapStruct struct {
	Field map[uint8]uint8 `valid:"required"`
}

type ValidatorRequiredUint8MapStruct struct {
	Field map[uint8]uint8 `validate:"required"`
}

type ValidGenRequiredUint16MapStruct struct {
	Field map[uint16]uint16 `valid:"required"`
}

type ValidatorRequiredUint16MapStruct struct {
	Field map[uint16]uint16 `validate:"required"`
}

type ValidGenRequiredUint32MapStruct struct {
	Field map[uint32]uint32 `valid:"required"`
}

type ValidatorRequiredUint32MapStruct struct {
	Field map[uint32]uint32 `validate:"required"`
}

type ValidGenRequiredUint64MapStruct struct {
	Field map[uint64]uint64 `valid:"required"`
}

type ValidatorRequiredUint64MapStruct struct {
	Field map[uint64]uint64 `validate:"required"`
}

type ValidGenRequiredFloat32MapStruct struct {
	Field map[float32]float32 `valid:"required"`
}

type ValidatorRequiredFloat32MapStruct struct {
	Field map[float32]float32 `validate:"required"`
}

type ValidGenRequiredFloat64MapStruct struct {
	Field map[float64]float64 `valid:"required"`
}

type ValidatorRequiredFloat64MapStruct struct {
	Field map[float64]float64 `validate:"required"`
}

type ValidGenRequiredBoolMapStruct struct {
	Field map[bool]bool `valid:"required"`
}

type ValidatorRequiredBoolMapStruct struct {
	Field map[bool]bool `validate:"required"`
}

type ValidGenEqStringStruct struct {
	Field string `valid:"eq=abcde"`
}

type ValidatorEqStringStruct struct {
	Field string `validate:"eq=abcde"`
}

type ValidGenEqIntStruct struct {
	Field int `valid:"eq=32"`
}

type ValidatorEqIntStruct struct {
	Field int `validate:"eq=32"`
}

type ValidGenEqInt8Struct struct {
	Field int8 `valid:"eq=32"`
}

type ValidatorEqInt8Struct struct {
	Field int8 `validate:"eq=32"`
}

type ValidGenEqInt16Struct struct {
	Field int16 `valid:"eq=32"`
}

type ValidatorEqInt16Struct struct {
	Field int16 `validate:"eq=32"`
}

type ValidGenEqInt32Struct struct {
	Field int32 `valid:"eq=32"`
}

type ValidatorEqInt32Struct struct {
	Field int32 `validate:"eq=32"`
}

type ValidGenEqInt64Struct struct {
	Field int64 `valid:"eq=32"`
}

type ValidatorEqInt64Struct struct {
	Field int64 `validate:"eq=32"`
}

type ValidGenEqUintStruct struct {
	Field uint `valid:"eq=32"`
}

type ValidatorEqUintStruct struct {
	Field uint `validate:"eq=32"`
}

type ValidGenEqUint8Struct struct {
	Field uint8 `valid:"eq=32"`
}

type ValidatorEqUint8Struct struct {
	Field uint8 `validate:"eq=32"`
}

type ValidGenEqUint16Struct struct {
	Field uint16 `valid:"eq=32"`
}

type ValidatorEqUint16Struct struct {
	Field uint16 `validate:"eq=32"`
}

type ValidGenEqUint32Struct struct {
	Field uint32 `valid:"eq=32"`
}

type ValidatorEqUint32Struct struct {
	Field uint32 `validate:"eq=32"`
}

type ValidGenEqUint64Struct struct {
	Field uint64 `valid:"eq=32"`
}

type ValidatorEqUint64Struct struct {
	Field uint64 `validate:"eq=32"`
}

type ValidGenEqFloat32Struct struct {
	Field float32 `valid:"eq=12.34"`
}

type ValidatorEqFloat32Struct struct {
	Field float32 `validate:"eq=12.34"`
}

type ValidGenEqFloat64Struct struct {
	Field float64 `valid:"eq=12.34"`
}

type ValidatorEqFloat64Struct struct {
	Field float64 `validate:"eq=12.34"`
}

type ValidGenEqBoolStruct struct {
	Field bool `valid:"eq=true"`
}

type ValidatorEqBoolStruct struct {
	Field bool `validate:"eq=true"`
}

type ValidGenNeqStringStruct struct {
	Field string `valid:"neq=abcde"`
}

type ValidatorNeqStringStruct struct {
	Field string `validate:"ne=abcde"`
}

type ValidGenNeqIntStruct struct {
	Field int `valid:"neq=32"`
}

type ValidatorNeqIntStruct struct {
	Field int `validate:"ne=32"`
}

type ValidGenNeqInt8Struct struct {
	Field int8 `valid:"neq=32"`
}

type ValidatorNeqInt8Struct struct {
	Field int8 `validate:"ne=32"`
}

type ValidGenNeqInt16Struct struct {
	Field int16 `valid:"neq=32"`
}

type ValidatorNeqInt16Struct struct {
	Field int16 `validate:"ne=32"`
}

type ValidGenNeqInt32Struct struct {
	Field int32 `valid:"neq=32"`
}

type ValidatorNeqInt32Struct struct {
	Field int32 `validate:"ne=32"`
}

type ValidGenNeqInt64Struct struct {
	Field int64 `valid:"neq=32"`
}

type ValidatorNeqInt64Struct struct {
	Field int64 `validate:"ne=32"`
}

type ValidGenNeqUintStruct struct {
	Field uint `valid:"neq=32"`
}

type ValidatorNeqUintStruct struct {
	Field uint `validate:"ne=32"`
}

type ValidGenNeqUint8Struct struct {
	Field uint8 `valid:"neq=32"`
}

type ValidatorNeqUint8Struct struct {
	Field uint8 `validate:"ne=32"`
}

type ValidGenNeqUint16Struct struct {
	Field uint16 `valid:"neq=32"`
}

type ValidatorNeqUint16Struct struct {
	Field uint16 `validate:"ne=32"`
}

type ValidGenNeqUint32Struct struct {
	Field uint32 `valid:"neq=32"`
}

type ValidatorNeqUint32Struct struct {
	Field uint32 `validate:"ne=32"`
}

type ValidGenNeqUint64Struct struct {
	Field uint64 `valid:"neq=32"`
}

type ValidatorNeqUint64Struct struct {
	Field uint64 `validate:"ne=32"`
}

type ValidGenNeqFloat32Struct struct {
	Field float32 `valid:"neq=12.34"`
}

type ValidatorNeqFloat32Struct struct {
	Field float32 `validate:"ne=12.34"`
}

type ValidGenNeqFloat64Struct struct {
	Field float64 `valid:"neq=12.34"`
}

type ValidatorNeqFloat64Struct struct {
	Field float64 `validate:"ne=12.34"`
}

type ValidGenNeqBoolStruct struct {
	Field bool `valid:"neq=true"`
}

type ValidatorNeqBoolStruct struct {
	Field bool `validate:"ne=true"`
}

type ValidGenGtIntStruct struct {
	Field int `valid:"gt=32"`
}

type ValidatorGtIntStruct struct {
	Field int `validate:"gt=32"`
}

type ValidGenGtInt8Struct struct {
	Field int8 `valid:"gt=32"`
}

type ValidatorGtInt8Struct struct {
	Field int8 `validate:"gt=32"`
}

type ValidGenGtInt16Struct struct {
	Field int16 `valid:"gt=32"`
}

type ValidatorGtInt16Struct struct {
	Field int16 `validate:"gt=32"`
}

type ValidGenGtInt32Struct struct {
	Field int32 `valid:"gt=32"`
}

type ValidatorGtInt32Struct struct {
	Field int32 `validate:"gt=32"`
}

type ValidGenGtInt64Struct struct {
	Field int64 `valid:"gt=32"`
}

type ValidatorGtInt64Struct struct {
	Field int64 `validate:"gt=32"`
}

type ValidGenGtUintStruct struct {
	Field uint `valid:"gt=32"`
}

type ValidatorGtUintStruct struct {
	Field uint `validate:"gt=32"`
}

type ValidGenGtUint8Struct struct {
	Field uint8 `valid:"gt=32"`
}

type ValidatorGtUint8Struct struct {
	Field uint8 `validate:"gt=32"`
}

type ValidGenGtUint16Struct struct {
	Field uint16 `valid:"gt=32"`
}

type ValidatorGtUint16Struct struct {
	Field uint16 `validate:"gt=32"`
}

type ValidGenGtUint32Struct struct {
	Field uint32 `valid:"gt=32"`
}

type ValidatorGtUint32Struct struct {
	Field uint32 `validate:"gt=32"`
}

type ValidGenGtUint64Struct struct {
	Field uint64 `valid:"gt=32"`
}

type ValidatorGtUint64Struct struct {
	Field uint64 `validate:"gt=32"`
}

type ValidGenGtFloat32Struct struct {
	Field float32 `valid:"gt=12.34"`
}

type ValidatorGtFloat32Struct struct {
	Field float32 `validate:"gt=12.34"`
}

type ValidGenGtFloat64Struct struct {
	Field float64 `valid:"gt=12.34"`
}

type ValidatorGtFloat64Struct struct {
	Field float64 `validate:"gt=12.34"`
}

type ValidGenGteIntStruct struct {
	Field int `valid:"gte=32"`
}

type ValidatorGteIntStruct struct {
	Field int `validate:"gte=32"`
}

type ValidGenGteInt8Struct struct {
	Field int8 `valid:"gte=32"`
}

type ValidatorGteInt8Struct struct {
	Field int8 `validate:"gte=32"`
}

type ValidGenGteInt16Struct struct {
	Field int16 `valid:"gte=32"`
}

type ValidatorGteInt16Struct struct {
	Field int16 `validate:"gte=32"`
}

type ValidGenGteInt32Struct struct {
	Field int32 `valid:"gte=32"`
}

type ValidatorGteInt32Struct struct {
	Field int32 `validate:"gte=32"`
}

type ValidGenGteInt64Struct struct {
	Field int64 `valid:"gte=32"`
}

type ValidatorGteInt64Struct struct {
	Field int64 `validate:"gte=32"`
}

type ValidGenGteUintStruct struct {
	Field uint `valid:"gte=32"`
}

type ValidatorGteUintStruct struct {
	Field uint `validate:"gte=32"`
}

type ValidGenGteUint8Struct struct {
	Field uint8 `valid:"gte=32"`
}

type ValidatorGteUint8Struct struct {
	Field uint8 `validate:"gte=32"`
}

type ValidGenGteUint16Struct struct {
	Field uint16 `valid:"gte=32"`
}

type ValidatorGteUint16Struct struct {
	Field uint16 `validate:"gte=32"`
}

type ValidGenGteUint32Struct struct {
	Field uint32 `valid:"gte=32"`
}

type ValidatorGteUint32Struct struct {
	Field uint32 `validate:"gte=32"`
}

type ValidGenGteUint64Struct struct {
	Field uint64 `valid:"gte=32"`
}

type ValidatorGteUint64Struct struct {
	Field uint64 `validate:"gte=32"`
}

type ValidGenGteFloat32Struct struct {
	Field float32 `valid:"gte=12.34"`
}

type ValidatorGteFloat32Struct struct {
	Field float32 `validate:"gte=12.34"`
}

type ValidGenGteFloat64Struct struct {
	Field float64 `valid:"gte=12.34"`
}

type ValidatorGteFloat64Struct struct {
	Field float64 `validate:"gte=12.34"`
}

type ValidGenLtIntStruct struct {
	Field int `valid:"lt=32"`
}

type ValidatorLtIntStruct struct {
	Field int `validate:"lt=32"`
}

type ValidGenLtInt8Struct struct {
	Field int8 `valid:"lt=32"`
}

type ValidatorLtInt8Struct struct {
	Field int8 `validate:"lt=32"`
}

type ValidGenLtInt16Struct struct {
	Field int16 `valid:"lt=32"`
}

type ValidatorLtInt16Struct struct {
	Field int16 `validate:"lt=32"`
}

type ValidGenLtInt32Struct struct {
	Field int32 `valid:"lt=32"`
}

type ValidatorLtInt32Struct struct {
	Field int32 `validate:"lt=32"`
}

type ValidGenLtInt64Struct struct {
	Field int64 `valid:"lt=32"`
}

type ValidatorLtInt64Struct struct {
	Field int64 `validate:"lt=32"`
}

type ValidGenLtUintStruct struct {
	Field uint `valid:"lt=32"`
}

type ValidatorLtUintStruct struct {
	Field uint `validate:"lt=32"`
}

type ValidGenLtUint8Struct struct {
	Field uint8 `valid:"lt=32"`
}

type ValidatorLtUint8Struct struct {
	Field uint8 `validate:"lt=32"`
}

type ValidGenLtUint16Struct struct {
	Field uint16 `valid:"lt=32"`
}

type ValidatorLtUint16Struct struct {
	Field uint16 `validate:"lt=32"`
}

type ValidGenLtUint32Struct struct {
	Field uint32 `valid:"lt=32"`
}

type ValidatorLtUint32Struct struct {
	Field uint32 `validate:"lt=32"`
}

type ValidGenLtUint64Struct struct {
	Field uint64 `valid:"lt=32"`
}

type ValidatorLtUint64Struct struct {
	Field uint64 `validate:"lt=32"`
}

type ValidGenLtFloat32Struct struct {
	Field float32 `valid:"lt=12.34"`
}

type ValidatorLtFloat32Struct struct {
	Field float32 `validate:"lt=12.34"`
}

type ValidGenLtFloat64Struct struct {
	Field float64 `valid:"lt=12.34"`
}

type ValidatorLtFloat64Struct struct {
	Field float64 `validate:"lt=12.34"`
}

type ValidGenLteIntStruct struct {
	Field int `valid:"lte=32"`
}

type ValidatorLteIntStruct struct {
	Field int `validate:"lte=32"`
}

type ValidGenLteInt8Struct struct {
	Field int8 `valid:"lte=32"`
}

type ValidatorLteInt8Struct struct {
	Field int8 `validate:"lte=32"`
}

type ValidGenLteInt16Struct struct {
	Field int16 `valid:"lte=32"`
}

type ValidatorLteInt16Struct struct {
	Field int16 `validate:"lte=32"`
}

type ValidGenLteInt32Struct struct {
	Field int32 `valid:"lte=32"`
}

type ValidatorLteInt32Struct struct {
	Field int32 `validate:"lte=32"`
}

type ValidGenLteInt64Struct struct {
	Field int64 `valid:"lte=32"`
}

type ValidatorLteInt64Struct struct {
	Field int64 `validate:"lte=32"`
}

type ValidGenLteUintStruct struct {
	Field uint `valid:"lte=32"`
}

type ValidatorLteUintStruct struct {
	Field uint `validate:"lte=32"`
}

type ValidGenLteUint8Struct struct {
	Field uint8 `valid:"lte=32"`
}

type ValidatorLteUint8Struct struct {
	Field uint8 `validate:"lte=32"`
}

type ValidGenLteUint16Struct struct {
	Field uint16 `valid:"lte=32"`
}

type ValidatorLteUint16Struct struct {
	Field uint16 `validate:"lte=32"`
}

type ValidGenLteUint32Struct struct {
	Field uint32 `valid:"lte=32"`
}

type ValidatorLteUint32Struct struct {
	Field uint32 `validate:"lte=32"`
}

type ValidGenLteUint64Struct struct {
	Field uint64 `valid:"lte=32"`
}

type ValidatorLteUint64Struct struct {
	Field uint64 `validate:"lte=32"`
}

type ValidGenLteFloat32Struct struct {
	Field float32 `valid:"lte=12.34"`
}

type ValidatorLteFloat32Struct struct {
	Field float32 `validate:"lte=12.34"`
}

type ValidGenLteFloat64Struct struct {
	Field float64 `valid:"lte=12.34"`
}

type ValidatorLteFloat64Struct struct {
	Field float64 `validate:"lte=12.34"`
}

type ValidGenMinStringStruct struct {
	Field string `valid:"min=5"`
}

type ValidatorMinStringStruct struct {
	Field string `validate:"min=5"`
}

type ValidGenMinStringSliceStruct struct {
	Field []string `valid:"min=2"`
}

type ValidatorMinStringSliceStruct struct {
	Field []string `validate:"min=2"`
}

type ValidGenMinIntSliceStruct struct {
	Field []int `valid:"min=2"`
}

type ValidatorMinIntSliceStruct struct {
	Field []int `validate:"min=2"`
}

type ValidGenMinInt8SliceStruct struct {
	Field []int8 `valid:"min=2"`
}

type ValidatorMinInt8SliceStruct struct {
	Field []int8 `validate:"min=2"`
}

type ValidGenMinInt16SliceStruct struct {
	Field []int16 `valid:"min=2"`
}

type ValidatorMinInt16SliceStruct struct {
	Field []int16 `validate:"min=2"`
}

type ValidGenMinInt32SliceStruct struct {
	Field []int32 `valid:"min=2"`
}

type ValidatorMinInt32SliceStruct struct {
	Field []int32 `validate:"min=2"`
}

type ValidGenMinInt64SliceStruct struct {
	Field []int64 `valid:"min=2"`
}

type ValidatorMinInt64SliceStruct struct {
	Field []int64 `validate:"min=2"`
}

type ValidGenMinUintSliceStruct struct {
	Field []uint `valid:"min=2"`
}

type ValidatorMinUintSliceStruct struct {
	Field []uint `validate:"min=2"`
}

type ValidGenMinUint8SliceStruct struct {
	Field []uint8 `valid:"min=2"`
}

type ValidatorMinUint8SliceStruct struct {
	Field []uint8 `validate:"min=2"`
}

type ValidGenMinUint16SliceStruct struct {
	Field []uint16 `valid:"min=2"`
}

type ValidatorMinUint16SliceStruct struct {
	Field []uint16 `validate:"min=2"`
}

type ValidGenMinUint32SliceStruct struct {
	Field []uint32 `valid:"min=2"`
}

type ValidatorMinUint32SliceStruct struct {
	Field []uint32 `validate:"min=2"`
}

type ValidGenMinUint64SliceStruct struct {
	Field []uint64 `valid:"min=2"`
}

type ValidatorMinUint64SliceStruct struct {
	Field []uint64 `validate:"min=2"`
}

type ValidGenMinFloat32SliceStruct struct {
	Field []float32 `valid:"min=2"`
}

type ValidatorMinFloat32SliceStruct struct {
	Field []float32 `validate:"min=2"`
}

type ValidGenMinFloat64SliceStruct struct {
	Field []float64 `valid:"min=2"`
}

type ValidatorMinFloat64SliceStruct struct {
	Field []float64 `validate:"min=2"`
}

type ValidGenMinBoolSliceStruct struct {
	Field []bool `valid:"min=2"`
}

type ValidatorMinBoolSliceStruct struct {
	Field []bool `validate:"min=2"`
}

type ValidGenMinStringMapStruct struct {
	Field map[string]string `valid:"min=2"`
}

type ValidatorMinStringMapStruct struct {
	Field map[string]string `validate:"min=2"`
}

type ValidGenMinIntMapStruct struct {
	Field map[int]int `valid:"min=2"`
}

type ValidatorMinIntMapStruct struct {
	Field map[int]int `validate:"min=2"`
}

type ValidGenMinInt8MapStruct struct {
	Field map[int8]int8 `valid:"min=2"`
}

type ValidatorMinInt8MapStruct struct {
	Field map[int8]int8 `validate:"min=2"`
}

type ValidGenMinInt16MapStruct struct {
	Field map[int16]int16 `valid:"min=2"`
}

type ValidatorMinInt16MapStruct struct {
	Field map[int16]int16 `validate:"min=2"`
}

type ValidGenMinInt32MapStruct struct {
	Field map[int32]int32 `valid:"min=2"`
}

type ValidatorMinInt32MapStruct struct {
	Field map[int32]int32 `validate:"min=2"`
}

type ValidGenMinInt64MapStruct struct {
	Field map[int64]int64 `valid:"min=2"`
}

type ValidatorMinInt64MapStruct struct {
	Field map[int64]int64 `validate:"min=2"`
}

type ValidGenMinUintMapStruct struct {
	Field map[uint]uint `valid:"min=2"`
}

type ValidatorMinUintMapStruct struct {
	Field map[uint]uint `validate:"min=2"`
}

type ValidGenMinUint8MapStruct struct {
	Field map[uint8]uint8 `valid:"min=2"`
}

type ValidatorMinUint8MapStruct struct {
	Field map[uint8]uint8 `validate:"min=2"`
}

type ValidGenMinUint16MapStruct struct {
	Field map[uint16]uint16 `valid:"min=2"`
}

type ValidatorMinUint16MapStruct struct {
	Field map[uint16]uint16 `validate:"min=2"`
}

type ValidGenMinUint32MapStruct struct {
	Field map[uint32]uint32 `valid:"min=2"`
}

type ValidatorMinUint32MapStruct struct {
	Field map[uint32]uint32 `validate:"min=2"`
}

type ValidGenMinUint64MapStruct struct {
	Field map[uint64]uint64 `valid:"min=2"`
}

type ValidatorMinUint64MapStruct struct {
	Field map[uint64]uint64 `validate:"min=2"`
}

type ValidGenMinFloat32MapStruct struct {
	Field map[float32]float32 `valid:"min=2"`
}

type ValidatorMinFloat32MapStruct struct {
	Field map[float32]float32 `validate:"min=2"`
}

type ValidGenMinFloat64MapStruct struct {
	Field map[float64]float64 `valid:"min=2"`
}

type ValidatorMinFloat64MapStruct struct {
	Field map[float64]float64 `validate:"min=2"`
}

type ValidGenMinBoolMapStruct struct {
	Field map[bool]bool `valid:"min=2"`
}

type ValidatorMinBoolMapStruct struct {
	Field map[bool]bool `validate:"min=2"`
}

type ValidGenMaxStringStruct struct {
	Field string `valid:"max=3"`
}

type ValidatorMaxStringStruct struct {
	Field string `validate:"max=3"`
}

type ValidGenMaxStringSliceStruct struct {
	Field []string `valid:"max=2"`
}

type ValidatorMaxStringSliceStruct struct {
	Field []string `validate:"max=2"`
}

type ValidGenMaxIntSliceStruct struct {
	Field []int `valid:"max=2"`
}

type ValidatorMaxIntSliceStruct struct {
	Field []int `validate:"max=2"`
}

type ValidGenMaxInt8SliceStruct struct {
	Field []int8 `valid:"max=2"`
}

type ValidatorMaxInt8SliceStruct struct {
	Field []int8 `validate:"max=2"`
}

type ValidGenMaxInt16SliceStruct struct {
	Field []int16 `valid:"max=2"`
}

type ValidatorMaxInt16SliceStruct struct {
	Field []int16 `validate:"max=2"`
}

type ValidGenMaxInt32SliceStruct struct {
	Field []int32 `valid:"max=2"`
}

type ValidatorMaxInt32SliceStruct struct {
	Field []int32 `validate:"max=2"`
}

type ValidGenMaxInt64SliceStruct struct {
	Field []int64 `valid:"max=2"`
}

type ValidatorMaxInt64SliceStruct struct {
	Field []int64 `validate:"max=2"`
}

type ValidGenMaxUintSliceStruct struct {
	Field []uint `valid:"max=2"`
}

type ValidatorMaxUintSliceStruct struct {
	Field []uint `validate:"max=2"`
}

type ValidGenMaxUint8SliceStruct struct {
	Field []uint8 `valid:"max=2"`
}

type ValidatorMaxUint8SliceStruct struct {
	Field []uint8 `validate:"max=2"`
}

type ValidGenMaxUint16SliceStruct struct {
	Field []uint16 `valid:"max=2"`
}

type ValidatorMaxUint16SliceStruct struct {
	Field []uint16 `validate:"max=2"`
}

type ValidGenMaxUint32SliceStruct struct {
	Field []uint32 `valid:"max=2"`
}

type ValidatorMaxUint32SliceStruct struct {
	Field []uint32 `validate:"max=2"`
}

type ValidGenMaxUint64SliceStruct struct {
	Field []uint64 `valid:"max=2"`
}

type ValidatorMaxUint64SliceStruct struct {
	Field []uint64 `validate:"max=2"`
}

type ValidGenMaxFloat32SliceStruct struct {
	Field []float32 `valid:"max=2"`
}

type ValidatorMaxFloat32SliceStruct struct {
	Field []float32 `validate:"max=2"`
}

type ValidGenMaxFloat64SliceStruct struct {
	Field []float64 `valid:"max=2"`
}

type ValidatorMaxFloat64SliceStruct struct {
	Field []float64 `validate:"max=2"`
}

type ValidGenMaxBoolSliceStruct struct {
	Field []bool `valid:"max=2"`
}

type ValidatorMaxBoolSliceStruct struct {
	Field []bool `validate:"max=2"`
}

type ValidGenMaxStringMapStruct struct {
	Field map[string]string `valid:"max=2"`
}

type ValidatorMaxStringMapStruct struct {
	Field map[string]string `validate:"max=2"`
}

type ValidGenMaxIntMapStruct struct {
	Field map[int]int `valid:"max=2"`
}

type ValidatorMaxIntMapStruct struct {
	Field map[int]int `validate:"max=2"`
}

type ValidGenMaxInt8MapStruct struct {
	Field map[int8]int8 `valid:"max=2"`
}

type ValidatorMaxInt8MapStruct struct {
	Field map[int8]int8 `validate:"max=2"`
}

type ValidGenMaxInt16MapStruct struct {
	Field map[int16]int16 `valid:"max=2"`
}

type ValidatorMaxInt16MapStruct struct {
	Field map[int16]int16 `validate:"max=2"`
}

type ValidGenMaxInt32MapStruct struct {
	Field map[int32]int32 `valid:"max=2"`
}

type ValidatorMaxInt32MapStruct struct {
	Field map[int32]int32 `validate:"max=2"`
}

type ValidGenMaxInt64MapStruct struct {
	Field map[int64]int64 `valid:"max=2"`
}

type ValidatorMaxInt64MapStruct struct {
	Field map[int64]int64 `validate:"max=2"`
}

type ValidGenMaxUintMapStruct struct {
	Field map[uint]uint `valid:"max=2"`
}

type ValidatorMaxUintMapStruct struct {
	Field map[uint]uint `validate:"max=2"`
}

type ValidGenMaxUint8MapStruct struct {
	Field map[uint8]uint8 `valid:"max=2"`
}

type ValidatorMaxUint8MapStruct struct {
	Field map[uint8]uint8 `validate:"max=2"`
}

type ValidGenMaxUint16MapStruct struct {
	Field map[uint16]uint16 `valid:"max=2"`
}

type ValidatorMaxUint16MapStruct struct {
	Field map[uint16]uint16 `validate:"max=2"`
}

type ValidGenMaxUint32MapStruct struct {
	Field map[uint32]uint32 `valid:"max=2"`
}

type ValidatorMaxUint32MapStruct struct {
	Field map[uint32]uint32 `validate:"max=2"`
}

type ValidGenMaxUint64MapStruct struct {
	Field map[uint64]uint64 `valid:"max=2"`
}

type ValidatorMaxUint64MapStruct struct {
	Field map[uint64]uint64 `validate:"max=2"`
}

type ValidGenMaxFloat32MapStruct struct {
	Field map[float32]float32 `valid:"max=2"`
}

type ValidatorMaxFloat32MapStruct struct {
	Field map[float32]float32 `validate:"max=2"`
}

type ValidGenMaxFloat64MapStruct struct {
	Field map[float64]float64 `valid:"max=2"`
}

type ValidatorMaxFloat64MapStruct struct {
	Field map[float64]float64 `validate:"max=2"`
}

type ValidGenMaxBoolMapStruct struct {
	Field map[bool]bool `valid:"max=1"`
}

type ValidatorMaxBoolMapStruct struct {
	Field map[bool]bool `validate:"max=1"`
}

type ValidGenEq_ignore_caseStringStruct struct {
	Field string `valid:"eq_ignore_case=abcde"`
}

type ValidatorEq_ignore_caseStringStruct struct {
	Field string `validate:"eq_ignore_case=abcde"`
}

type ValidGenNeq_ignore_caseStringStruct struct {
	Field string `valid:"neq_ignore_case=abcde"`
}

type ValidatorNeq_ignore_caseStringStruct struct {
	Field string `validate:"ne_ignore_case=abcde"`
}

type ValidGenLenStringStruct struct {
	Field string `valid:"len=2"`
}

type ValidatorLenStringStruct struct {
	Field string `validate:"len=2"`
}

type ValidGenLenStringSliceStruct struct {
	Field []string `valid:"len=2"`
}

type ValidatorLenStringSliceStruct struct {
	Field []string `validate:"len=2"`
}

type ValidGenLenIntSliceStruct struct {
	Field []int `valid:"len=2"`
}

type ValidatorLenIntSliceStruct struct {
	Field []int `validate:"len=2"`
}

type ValidGenLenInt8SliceStruct struct {
	Field []int8 `valid:"len=2"`
}

type ValidatorLenInt8SliceStruct struct {
	Field []int8 `validate:"len=2"`
}

type ValidGenLenInt16SliceStruct struct {
	Field []int16 `valid:"len=2"`
}

type ValidatorLenInt16SliceStruct struct {
	Field []int16 `validate:"len=2"`
}

type ValidGenLenInt32SliceStruct struct {
	Field []int32 `valid:"len=2"`
}

type ValidatorLenInt32SliceStruct struct {
	Field []int32 `validate:"len=2"`
}

type ValidGenLenInt64SliceStruct struct {
	Field []int64 `valid:"len=2"`
}

type ValidatorLenInt64SliceStruct struct {
	Field []int64 `validate:"len=2"`
}

type ValidGenLenUintSliceStruct struct {
	Field []uint `valid:"len=2"`
}

type ValidatorLenUintSliceStruct struct {
	Field []uint `validate:"len=2"`
}

type ValidGenLenUint8SliceStruct struct {
	Field []uint8 `valid:"len=2"`
}

type ValidatorLenUint8SliceStruct struct {
	Field []uint8 `validate:"len=2"`
}

type ValidGenLenUint16SliceStruct struct {
	Field []uint16 `valid:"len=2"`
}

type ValidatorLenUint16SliceStruct struct {
	Field []uint16 `validate:"len=2"`
}

type ValidGenLenUint32SliceStruct struct {
	Field []uint32 `valid:"len=2"`
}

type ValidatorLenUint32SliceStruct struct {
	Field []uint32 `validate:"len=2"`
}

type ValidGenLenUint64SliceStruct struct {
	Field []uint64 `valid:"len=2"`
}

type ValidatorLenUint64SliceStruct struct {
	Field []uint64 `validate:"len=2"`
}

type ValidGenLenFloat32SliceStruct struct {
	Field []float32 `valid:"len=2"`
}

type ValidatorLenFloat32SliceStruct struct {
	Field []float32 `validate:"len=2"`
}

type ValidGenLenFloat64SliceStruct struct {
	Field []float64 `valid:"len=2"`
}

type ValidatorLenFloat64SliceStruct struct {
	Field []float64 `validate:"len=2"`
}

type ValidGenLenBoolSliceStruct struct {
	Field []bool `valid:"len=2"`
}

type ValidatorLenBoolSliceStruct struct {
	Field []bool `validate:"len=2"`
}

type ValidGenLenStringMapStruct struct {
	Field map[string]string `valid:"len=2"`
}

type ValidatorLenStringMapStruct struct {
	Field map[string]string `validate:"len=2"`
}

type ValidGenLenIntMapStruct struct {
	Field map[int]int `valid:"len=2"`
}

type ValidatorLenIntMapStruct struct {
	Field map[int]int `validate:"len=2"`
}

type ValidGenLenInt8MapStruct struct {
	Field map[int8]int8 `valid:"len=2"`
}

type ValidatorLenInt8MapStruct struct {
	Field map[int8]int8 `validate:"len=2"`
}

type ValidGenLenInt16MapStruct struct {
	Field map[int16]int16 `valid:"len=2"`
}

type ValidatorLenInt16MapStruct struct {
	Field map[int16]int16 `validate:"len=2"`
}

type ValidGenLenInt32MapStruct struct {
	Field map[int32]int32 `valid:"len=2"`
}

type ValidatorLenInt32MapStruct struct {
	Field map[int32]int32 `validate:"len=2"`
}

type ValidGenLenInt64MapStruct struct {
	Field map[int64]int64 `valid:"len=2"`
}

type ValidatorLenInt64MapStruct struct {
	Field map[int64]int64 `validate:"len=2"`
}

type ValidGenLenUintMapStruct struct {
	Field map[uint]uint `valid:"len=2"`
}

type ValidatorLenUintMapStruct struct {
	Field map[uint]uint `validate:"len=2"`
}

type ValidGenLenUint8MapStruct struct {
	Field map[uint8]uint8 `valid:"len=2"`
}

type ValidatorLenUint8MapStruct struct {
	Field map[uint8]uint8 `validate:"len=2"`
}

type ValidGenLenUint16MapStruct struct {
	Field map[uint16]uint16 `valid:"len=2"`
}

type ValidatorLenUint16MapStruct struct {
	Field map[uint16]uint16 `validate:"len=2"`
}

type ValidGenLenUint32MapStruct struct {
	Field map[uint32]uint32 `valid:"len=2"`
}

type ValidatorLenUint32MapStruct struct {
	Field map[uint32]uint32 `validate:"len=2"`
}

type ValidGenLenUint64MapStruct struct {
	Field map[uint64]uint64 `valid:"len=2"`
}

type ValidatorLenUint64MapStruct struct {
	Field map[uint64]uint64 `validate:"len=2"`
}

type ValidGenLenFloat32MapStruct struct {
	Field map[float32]float32 `valid:"len=2"`
}

type ValidatorLenFloat32MapStruct struct {
	Field map[float32]float32 `validate:"len=2"`
}

type ValidGenLenFloat64MapStruct struct {
	Field map[float64]float64 `valid:"len=2"`
}

type ValidatorLenFloat64MapStruct struct {
	Field map[float64]float64 `validate:"len=2"`
}

type ValidGenLenBoolMapStruct struct {
	Field map[bool]bool `valid:"len=2"`
}

type ValidatorLenBoolMapStruct struct {
	Field map[bool]bool `validate:"len=2"`
}

type ValidGenInStringStruct struct {
	Field string `valid:"in=ab cd ef"`
}

type ValidatorInStringStruct struct {
	Field string `validate:"oneof=ab cd ef"`
}

type ValidGenInIntStruct struct {
	Field int `valid:"in=12 34 56"`
}

type ValidatorInIntStruct struct {
	Field int `validate:"oneof=12 34 56"`
}

type ValidGenInInt8Struct struct {
	Field int8 `valid:"in=12 34 56"`
}

type ValidatorInInt8Struct struct {
	Field int8 `validate:"oneof=12 34 56"`
}

type ValidGenInInt16Struct struct {
	Field int16 `valid:"in=12 34 56"`
}

type ValidatorInInt16Struct struct {
	Field int16 `validate:"oneof=12 34 56"`
}

type ValidGenInInt32Struct struct {
	Field int32 `valid:"in=12 34 56"`
}

type ValidatorInInt32Struct struct {
	Field int32 `validate:"oneof=12 34 56"`
}

type ValidGenInInt64Struct struct {
	Field int64 `valid:"in=12 34 56"`
}

type ValidatorInInt64Struct struct {
	Field int64 `validate:"oneof=12 34 56"`
}

type ValidGenInUintStruct struct {
	Field uint `valid:"in=12 34 56"`
}

type ValidatorInUintStruct struct {
	Field uint `validate:"oneof=12 34 56"`
}

type ValidGenInUint8Struct struct {
	Field uint8 `valid:"in=12 34 56"`
}

type ValidatorInUint8Struct struct {
	Field uint8 `validate:"oneof=12 34 56"`
}

type ValidGenInUint16Struct struct {
	Field uint16 `valid:"in=12 34 56"`
}

type ValidatorInUint16Struct struct {
	Field uint16 `validate:"oneof=12 34 56"`
}

type ValidGenInUint32Struct struct {
	Field uint32 `valid:"in=12 34 56"`
}

type ValidatorInUint32Struct struct {
	Field uint32 `validate:"oneof=12 34 56"`
}

type ValidGenInUint64Struct struct {
	Field uint64 `valid:"in=12 34 56"`
}

type ValidatorInUint64Struct struct {
	Field uint64 `validate:"oneof=12 34 56"`
}

func BenchmarkValidGenEmailString(b *testing.B) {
	data := &ValidGenEmailStringStruct{
		Field: "abcde@example.com",
	}

	for b.Loop() {
		if err := ValidGenEmailStringStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEmailString(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEmailStringStruct{
		Field: "abcde@example.com",
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredString(b *testing.B) {
	data := &ValidGenRequiredStringStruct{
		Field: "abcde",
	}

	for b.Loop() {
		if err := ValidGenRequiredStringStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredString(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredStringStruct{
		Field: "abcde",
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt(b *testing.B) {
	data := &ValidGenRequiredIntStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenRequiredIntStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredIntStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt8(b *testing.B) {
	data := &ValidGenRequiredInt8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenRequiredInt8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt16(b *testing.B) {
	data := &ValidGenRequiredInt16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenRequiredInt16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt32(b *testing.B) {
	data := &ValidGenRequiredInt32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenRequiredInt32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt64(b *testing.B) {
	data := &ValidGenRequiredInt64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenRequiredInt64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint(b *testing.B) {
	data := &ValidGenRequiredUintStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenRequiredUintStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUintStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint8(b *testing.B) {
	data := &ValidGenRequiredUint8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenRequiredUint8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint16(b *testing.B) {
	data := &ValidGenRequiredUint16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenRequiredUint16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint32(b *testing.B) {
	data := &ValidGenRequiredUint32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenRequiredUint32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint64(b *testing.B) {
	data := &ValidGenRequiredUint64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenRequiredUint64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredFloat32(b *testing.B) {
	data := &ValidGenRequiredFloat32Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := ValidGenRequiredFloat32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredFloat32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredFloat32Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredFloat64(b *testing.B) {
	data := &ValidGenRequiredFloat64Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := ValidGenRequiredFloat64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredFloat64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredFloat64Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredBool(b *testing.B) {
	data := &ValidGenRequiredBoolStruct{
		Field: true,
	}

	for b.Loop() {
		if err := ValidGenRequiredBoolStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredBool(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredBoolStruct{
		Field: true,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredStringSlice(b *testing.B) {
	data := &ValidGenRequiredStringSliceStruct{
		Field: []string{"abcde"},
	}

	for b.Loop() {
		if err := ValidGenRequiredStringSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredStringSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredStringSliceStruct{
		Field: []string{"abcde"},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredIntSlice(b *testing.B) {
	data := &ValidGenRequiredIntSliceStruct{
		Field: []int{32},
	}

	for b.Loop() {
		if err := ValidGenRequiredIntSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredIntSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredIntSliceStruct{
		Field: []int{32},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt8Slice(b *testing.B) {
	data := &ValidGenRequiredInt8SliceStruct{
		Field: []int8{32},
	}

	for b.Loop() {
		if err := ValidGenRequiredInt8SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt8Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt8SliceStruct{
		Field: []int8{32},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt16Slice(b *testing.B) {
	data := &ValidGenRequiredInt16SliceStruct{
		Field: []int16{32},
	}

	for b.Loop() {
		if err := ValidGenRequiredInt16SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt16Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt16SliceStruct{
		Field: []int16{32},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt32Slice(b *testing.B) {
	data := &ValidGenRequiredInt32SliceStruct{
		Field: []int32{32},
	}

	for b.Loop() {
		if err := ValidGenRequiredInt32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt32SliceStruct{
		Field: []int32{32},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt64Slice(b *testing.B) {
	data := &ValidGenRequiredInt64SliceStruct{
		Field: []int64{32},
	}

	for b.Loop() {
		if err := ValidGenRequiredInt64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt64SliceStruct{
		Field: []int64{32},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUintSlice(b *testing.B) {
	data := &ValidGenRequiredUintSliceStruct{
		Field: []uint{32},
	}

	for b.Loop() {
		if err := ValidGenRequiredUintSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUintSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUintSliceStruct{
		Field: []uint{32},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint8Slice(b *testing.B) {
	data := &ValidGenRequiredUint8SliceStruct{
		Field: []uint8{32},
	}

	for b.Loop() {
		if err := ValidGenRequiredUint8SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint8Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint8SliceStruct{
		Field: []uint8{32},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint16Slice(b *testing.B) {
	data := &ValidGenRequiredUint16SliceStruct{
		Field: []uint16{32},
	}

	for b.Loop() {
		if err := ValidGenRequiredUint16SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint16Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint16SliceStruct{
		Field: []uint16{32},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint32Slice(b *testing.B) {
	data := &ValidGenRequiredUint32SliceStruct{
		Field: []uint32{32},
	}

	for b.Loop() {
		if err := ValidGenRequiredUint32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint32SliceStruct{
		Field: []uint32{32},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint64Slice(b *testing.B) {
	data := &ValidGenRequiredUint64SliceStruct{
		Field: []uint64{32},
	}

	for b.Loop() {
		if err := ValidGenRequiredUint64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint64SliceStruct{
		Field: []uint64{32},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredFloat32Slice(b *testing.B) {
	data := &ValidGenRequiredFloat32SliceStruct{
		Field: []float32{12.34},
	}

	for b.Loop() {
		if err := ValidGenRequiredFloat32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredFloat32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredFloat32SliceStruct{
		Field: []float32{12.34},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredFloat64Slice(b *testing.B) {
	data := &ValidGenRequiredFloat64SliceStruct{
		Field: []float64{12.34},
	}

	for b.Loop() {
		if err := ValidGenRequiredFloat64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredFloat64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredFloat64SliceStruct{
		Field: []float64{12.34},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredBoolSlice(b *testing.B) {
	data := &ValidGenRequiredBoolSliceStruct{
		Field: []bool{true},
	}

	for b.Loop() {
		if err := ValidGenRequiredBoolSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredBoolSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredBoolSliceStruct{
		Field: []bool{true},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredStringMap(b *testing.B) {
	data := &ValidGenRequiredStringMapStruct{
		Field: map[string]string{"abcde": "value"},
	}

	for b.Loop() {
		if err := ValidGenRequiredStringMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredStringMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredStringMapStruct{
		Field: map[string]string{"abcde": "value"},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredIntMap(b *testing.B) {
	data := &ValidGenRequiredIntMapStruct{
		Field: map[int]int{32: 64},
	}

	for b.Loop() {
		if err := ValidGenRequiredIntMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredIntMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredIntMapStruct{
		Field: map[int]int{32: 64},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt8Map(b *testing.B) {
	data := &ValidGenRequiredInt8MapStruct{
		Field: map[int8]int8{32: 64},
	}

	for b.Loop() {
		if err := ValidGenRequiredInt8MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt8Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt8MapStruct{
		Field: map[int8]int8{32: 64},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt16Map(b *testing.B) {
	data := &ValidGenRequiredInt16MapStruct{
		Field: map[int16]int16{32: 64},
	}

	for b.Loop() {
		if err := ValidGenRequiredInt16MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt16Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt16MapStruct{
		Field: map[int16]int16{32: 64},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt32Map(b *testing.B) {
	data := &ValidGenRequiredInt32MapStruct{
		Field: map[int32]int32{32: 64},
	}

	for b.Loop() {
		if err := ValidGenRequiredInt32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt32MapStruct{
		Field: map[int32]int32{32: 64},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredInt64Map(b *testing.B) {
	data := &ValidGenRequiredInt64MapStruct{
		Field: map[int64]int64{32: 64},
	}

	for b.Loop() {
		if err := ValidGenRequiredInt64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredInt64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredInt64MapStruct{
		Field: map[int64]int64{32: 64},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUintMap(b *testing.B) {
	data := &ValidGenRequiredUintMapStruct{
		Field: map[uint]uint{32: 64},
	}

	for b.Loop() {
		if err := ValidGenRequiredUintMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUintMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUintMapStruct{
		Field: map[uint]uint{32: 64},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint8Map(b *testing.B) {
	data := &ValidGenRequiredUint8MapStruct{
		Field: map[uint8]uint8{32: 64},
	}

	for b.Loop() {
		if err := ValidGenRequiredUint8MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint8Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint8MapStruct{
		Field: map[uint8]uint8{32: 64},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint16Map(b *testing.B) {
	data := &ValidGenRequiredUint16MapStruct{
		Field: map[uint16]uint16{32: 64},
	}

	for b.Loop() {
		if err := ValidGenRequiredUint16MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint16Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint16MapStruct{
		Field: map[uint16]uint16{32: 64},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint32Map(b *testing.B) {
	data := &ValidGenRequiredUint32MapStruct{
		Field: map[uint32]uint32{32: 64},
	}

	for b.Loop() {
		if err := ValidGenRequiredUint32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint32MapStruct{
		Field: map[uint32]uint32{32: 64},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredUint64Map(b *testing.B) {
	data := &ValidGenRequiredUint64MapStruct{
		Field: map[uint64]uint64{32: 64},
	}

	for b.Loop() {
		if err := ValidGenRequiredUint64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredUint64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredUint64MapStruct{
		Field: map[uint64]uint64{32: 64},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredFloat32Map(b *testing.B) {
	data := &ValidGenRequiredFloat32MapStruct{
		Field: map[float32]float32{12.34: 56.78},
	}

	for b.Loop() {
		if err := ValidGenRequiredFloat32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredFloat32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredFloat32MapStruct{
		Field: map[float32]float32{12.34: 56.78},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredFloat64Map(b *testing.B) {
	data := &ValidGenRequiredFloat64MapStruct{
		Field: map[float64]float64{12.34: 56.78},
	}

	for b.Loop() {
		if err := ValidGenRequiredFloat64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredFloat64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredFloat64MapStruct{
		Field: map[float64]float64{12.34: 56.78},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenRequiredBoolMap(b *testing.B) {
	data := &ValidGenRequiredBoolMapStruct{
		Field: map[bool]bool{true: true},
	}

	for b.Loop() {
		if err := ValidGenRequiredBoolMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorRequiredBoolMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorRequiredBoolMapStruct{
		Field: map[bool]bool{true: true},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqString(b *testing.B) {
	data := &ValidGenEqStringStruct{
		Field: "abcde",
	}

	for b.Loop() {
		if err := ValidGenEqStringStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqString(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqStringStruct{
		Field: "abcde",
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqInt(b *testing.B) {
	data := &ValidGenEqIntStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenEqIntStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqInt(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqIntStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqInt8(b *testing.B) {
	data := &ValidGenEqInt8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenEqInt8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqInt8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqInt8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqInt16(b *testing.B) {
	data := &ValidGenEqInt16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenEqInt16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqInt16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqInt16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqInt32(b *testing.B) {
	data := &ValidGenEqInt32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenEqInt32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqInt32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqInt32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqInt64(b *testing.B) {
	data := &ValidGenEqInt64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenEqInt64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqInt64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqInt64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqUint(b *testing.B) {
	data := &ValidGenEqUintStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenEqUintStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqUint(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqUintStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqUint8(b *testing.B) {
	data := &ValidGenEqUint8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenEqUint8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqUint8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqUint8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqUint16(b *testing.B) {
	data := &ValidGenEqUint16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenEqUint16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqUint16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqUint16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqUint32(b *testing.B) {
	data := &ValidGenEqUint32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenEqUint32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqUint32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqUint32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqUint64(b *testing.B) {
	data := &ValidGenEqUint64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenEqUint64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqUint64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqUint64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqFloat32(b *testing.B) {
	data := &ValidGenEqFloat32Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := ValidGenEqFloat32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqFloat32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqFloat32Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqFloat64(b *testing.B) {
	data := &ValidGenEqFloat64Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := ValidGenEqFloat64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqFloat64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqFloat64Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEqBool(b *testing.B) {
	data := &ValidGenEqBoolStruct{
		Field: true,
	}

	for b.Loop() {
		if err := ValidGenEqBoolStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEqBool(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEqBoolStruct{
		Field: true,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqString(b *testing.B) {
	data := &ValidGenNeqStringStruct{
		Field: "fghij",
	}

	for b.Loop() {
		if err := ValidGenNeqStringStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqString(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqStringStruct{
		Field: "fghij",
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqInt(b *testing.B) {
	data := &ValidGenNeqIntStruct{
		Field: 64,
	}

	for b.Loop() {
		if err := ValidGenNeqIntStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqInt(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqIntStruct{
		Field: 64,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqInt8(b *testing.B) {
	data := &ValidGenNeqInt8Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := ValidGenNeqInt8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqInt8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqInt8Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqInt16(b *testing.B) {
	data := &ValidGenNeqInt16Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := ValidGenNeqInt16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqInt16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqInt16Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqInt32(b *testing.B) {
	data := &ValidGenNeqInt32Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := ValidGenNeqInt32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqInt32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqInt32Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqInt64(b *testing.B) {
	data := &ValidGenNeqInt64Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := ValidGenNeqInt64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqInt64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqInt64Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqUint(b *testing.B) {
	data := &ValidGenNeqUintStruct{
		Field: 64,
	}

	for b.Loop() {
		if err := ValidGenNeqUintStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqUint(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqUintStruct{
		Field: 64,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqUint8(b *testing.B) {
	data := &ValidGenNeqUint8Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := ValidGenNeqUint8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqUint8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqUint8Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqUint16(b *testing.B) {
	data := &ValidGenNeqUint16Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := ValidGenNeqUint16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqUint16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqUint16Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqUint32(b *testing.B) {
	data := &ValidGenNeqUint32Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := ValidGenNeqUint32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqUint32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqUint32Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqUint64(b *testing.B) {
	data := &ValidGenNeqUint64Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := ValidGenNeqUint64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqUint64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqUint64Struct{
		Field: 64,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqFloat32(b *testing.B) {
	data := &ValidGenNeqFloat32Struct{
		Field: 34.56,
	}

	for b.Loop() {
		if err := ValidGenNeqFloat32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqFloat32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqFloat32Struct{
		Field: 34.56,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqFloat64(b *testing.B) {
	data := &ValidGenNeqFloat64Struct{
		Field: 34.56,
	}

	for b.Loop() {
		if err := ValidGenNeqFloat64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqFloat64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqFloat64Struct{
		Field: 34.56,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeqBool(b *testing.B) {
	data := &ValidGenNeqBoolStruct{
		Field: false,
	}

	for b.Loop() {
		if err := ValidGenNeqBoolStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeqBool(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeqBoolStruct{
		Field: false,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtInt(b *testing.B) {
	data := &ValidGenGtIntStruct{
		Field: 33,
	}

	for b.Loop() {
		if err := ValidGenGtIntStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtInt(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtIntStruct{
		Field: 33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtInt8(b *testing.B) {
	data := &ValidGenGtInt8Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := ValidGenGtInt8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtInt8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtInt8Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtInt16(b *testing.B) {
	data := &ValidGenGtInt16Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := ValidGenGtInt16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtInt16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtInt16Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtInt32(b *testing.B) {
	data := &ValidGenGtInt32Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := ValidGenGtInt32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtInt32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtInt32Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtInt64(b *testing.B) {
	data := &ValidGenGtInt64Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := ValidGenGtInt64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtInt64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtInt64Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtUint(b *testing.B) {
	data := &ValidGenGtUintStruct{
		Field: 33,
	}

	for b.Loop() {
		if err := ValidGenGtUintStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtUint(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtUintStruct{
		Field: 33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtUint8(b *testing.B) {
	data := &ValidGenGtUint8Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := ValidGenGtUint8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtUint8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtUint8Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtUint16(b *testing.B) {
	data := &ValidGenGtUint16Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := ValidGenGtUint16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtUint16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtUint16Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtUint32(b *testing.B) {
	data := &ValidGenGtUint32Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := ValidGenGtUint32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtUint32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtUint32Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtUint64(b *testing.B) {
	data := &ValidGenGtUint64Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := ValidGenGtUint64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtUint64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtUint64Struct{
		Field: 33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtFloat32(b *testing.B) {
	data := &ValidGenGtFloat32Struct{
		Field: 12.35,
	}

	for b.Loop() {
		if err := ValidGenGtFloat32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtFloat32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtFloat32Struct{
		Field: 12.35,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGtFloat64(b *testing.B) {
	data := &ValidGenGtFloat64Struct{
		Field: 12.35,
	}

	for b.Loop() {
		if err := ValidGenGtFloat64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGtFloat64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGtFloat64Struct{
		Field: 12.35,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteInt(b *testing.B) {
	data := &ValidGenGteIntStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenGteIntStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteInt(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteIntStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteInt8(b *testing.B) {
	data := &ValidGenGteInt8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenGteInt8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteInt8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteInt8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteInt16(b *testing.B) {
	data := &ValidGenGteInt16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenGteInt16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteInt16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteInt16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteInt32(b *testing.B) {
	data := &ValidGenGteInt32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenGteInt32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteInt32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteInt32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteInt64(b *testing.B) {
	data := &ValidGenGteInt64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenGteInt64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteInt64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteInt64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteUint(b *testing.B) {
	data := &ValidGenGteUintStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenGteUintStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteUint(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteUintStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteUint8(b *testing.B) {
	data := &ValidGenGteUint8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenGteUint8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteUint8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteUint8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteUint16(b *testing.B) {
	data := &ValidGenGteUint16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenGteUint16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteUint16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteUint16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteUint32(b *testing.B) {
	data := &ValidGenGteUint32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenGteUint32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteUint32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteUint32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteUint64(b *testing.B) {
	data := &ValidGenGteUint64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenGteUint64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteUint64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteUint64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteFloat32(b *testing.B) {
	data := &ValidGenGteFloat32Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := ValidGenGteFloat32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteFloat32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteFloat32Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenGteFloat64(b *testing.B) {
	data := &ValidGenGteFloat64Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := ValidGenGteFloat64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorGteFloat64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorGteFloat64Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtInt(b *testing.B) {
	data := &ValidGenLtIntStruct{
		Field: 31,
	}

	for b.Loop() {
		if err := ValidGenLtIntStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtInt(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtIntStruct{
		Field: 31,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtInt8(b *testing.B) {
	data := &ValidGenLtInt8Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := ValidGenLtInt8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtInt8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtInt8Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtInt16(b *testing.B) {
	data := &ValidGenLtInt16Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := ValidGenLtInt16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtInt16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtInt16Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtInt32(b *testing.B) {
	data := &ValidGenLtInt32Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := ValidGenLtInt32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtInt32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtInt32Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtInt64(b *testing.B) {
	data := &ValidGenLtInt64Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := ValidGenLtInt64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtInt64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtInt64Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtUint(b *testing.B) {
	data := &ValidGenLtUintStruct{
		Field: 31,
	}

	for b.Loop() {
		if err := ValidGenLtUintStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtUint(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtUintStruct{
		Field: 31,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtUint8(b *testing.B) {
	data := &ValidGenLtUint8Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := ValidGenLtUint8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtUint8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtUint8Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtUint16(b *testing.B) {
	data := &ValidGenLtUint16Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := ValidGenLtUint16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtUint16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtUint16Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtUint32(b *testing.B) {
	data := &ValidGenLtUint32Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := ValidGenLtUint32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtUint32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtUint32Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtUint64(b *testing.B) {
	data := &ValidGenLtUint64Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := ValidGenLtUint64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtUint64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtUint64Struct{
		Field: 31,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtFloat32(b *testing.B) {
	data := &ValidGenLtFloat32Struct{
		Field: 12.33,
	}

	for b.Loop() {
		if err := ValidGenLtFloat32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtFloat32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtFloat32Struct{
		Field: 12.33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLtFloat64(b *testing.B) {
	data := &ValidGenLtFloat64Struct{
		Field: 12.33,
	}

	for b.Loop() {
		if err := ValidGenLtFloat64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLtFloat64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLtFloat64Struct{
		Field: 12.33,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteInt(b *testing.B) {
	data := &ValidGenLteIntStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenLteIntStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteInt(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteIntStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteInt8(b *testing.B) {
	data := &ValidGenLteInt8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenLteInt8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteInt8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteInt8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteInt16(b *testing.B) {
	data := &ValidGenLteInt16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenLteInt16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteInt16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteInt16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteInt32(b *testing.B) {
	data := &ValidGenLteInt32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenLteInt32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteInt32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteInt32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteInt64(b *testing.B) {
	data := &ValidGenLteInt64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenLteInt64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteInt64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteInt64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteUint(b *testing.B) {
	data := &ValidGenLteUintStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenLteUintStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteUint(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteUintStruct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteUint8(b *testing.B) {
	data := &ValidGenLteUint8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenLteUint8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteUint8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteUint8Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteUint16(b *testing.B) {
	data := &ValidGenLteUint16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenLteUint16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteUint16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteUint16Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteUint32(b *testing.B) {
	data := &ValidGenLteUint32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenLteUint32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteUint32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteUint32Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteUint64(b *testing.B) {
	data := &ValidGenLteUint64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := ValidGenLteUint64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteUint64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteUint64Struct{
		Field: 32,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteFloat32(b *testing.B) {
	data := &ValidGenLteFloat32Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := ValidGenLteFloat32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteFloat32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteFloat32Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLteFloat64(b *testing.B) {
	data := &ValidGenLteFloat64Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := ValidGenLteFloat64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLteFloat64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLteFloat64Struct{
		Field: 12.34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinString(b *testing.B) {
	data := &ValidGenMinStringStruct{
		Field: "abcde",
	}

	for b.Loop() {
		if err := ValidGenMinStringStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinString(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinStringStruct{
		Field: "abcde",
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinStringSlice(b *testing.B) {
	data := &ValidGenMinStringSliceStruct{
		Field: []string{"abc", "def"},
	}

	for b.Loop() {
		if err := ValidGenMinStringSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinStringSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinStringSliceStruct{
		Field: []string{"abc", "def"},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinIntSlice(b *testing.B) {
	data := &ValidGenMinIntSliceStruct{
		Field: []int{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMinIntSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinIntSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinIntSliceStruct{
		Field: []int{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinInt8Slice(b *testing.B) {
	data := &ValidGenMinInt8SliceStruct{
		Field: []int8{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMinInt8SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinInt8Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinInt8SliceStruct{
		Field: []int8{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinInt16Slice(b *testing.B) {
	data := &ValidGenMinInt16SliceStruct{
		Field: []int16{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMinInt16SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinInt16Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinInt16SliceStruct{
		Field: []int16{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinInt32Slice(b *testing.B) {
	data := &ValidGenMinInt32SliceStruct{
		Field: []int32{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMinInt32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinInt32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinInt32SliceStruct{
		Field: []int32{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinInt64Slice(b *testing.B) {
	data := &ValidGenMinInt64SliceStruct{
		Field: []int64{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMinInt64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinInt64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinInt64SliceStruct{
		Field: []int64{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinUintSlice(b *testing.B) {
	data := &ValidGenMinUintSliceStruct{
		Field: []uint{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMinUintSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinUintSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinUintSliceStruct{
		Field: []uint{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinUint8Slice(b *testing.B) {
	data := &ValidGenMinUint8SliceStruct{
		Field: []uint8{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMinUint8SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinUint8Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinUint8SliceStruct{
		Field: []uint8{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinUint16Slice(b *testing.B) {
	data := &ValidGenMinUint16SliceStruct{
		Field: []uint16{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMinUint16SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinUint16Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinUint16SliceStruct{
		Field: []uint16{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinUint32Slice(b *testing.B) {
	data := &ValidGenMinUint32SliceStruct{
		Field: []uint32{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMinUint32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinUint32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinUint32SliceStruct{
		Field: []uint32{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinUint64Slice(b *testing.B) {
	data := &ValidGenMinUint64SliceStruct{
		Field: []uint64{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMinUint64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinUint64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinUint64SliceStruct{
		Field: []uint64{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinFloat32Slice(b *testing.B) {
	data := &ValidGenMinFloat32SliceStruct{
		Field: []float32{65.65, 67.67},
	}

	for b.Loop() {
		if err := ValidGenMinFloat32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinFloat32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinFloat32SliceStruct{
		Field: []float32{65.65, 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinFloat64Slice(b *testing.B) {
	data := &ValidGenMinFloat64SliceStruct{
		Field: []float64{65.65, 67.67},
	}

	for b.Loop() {
		if err := ValidGenMinFloat64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinFloat64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinFloat64SliceStruct{
		Field: []float64{65.65, 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinBoolSlice(b *testing.B) {
	data := &ValidGenMinBoolSliceStruct{
		Field: []bool{true, false},
	}

	for b.Loop() {
		if err := ValidGenMinBoolSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinBoolSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinBoolSliceStruct{
		Field: []bool{true, false},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinStringMap(b *testing.B) {
	data := &ValidGenMinStringMapStruct{
		Field: map[string]string{"a": "1", "b": "2"},
	}

	for b.Loop() {
		if err := ValidGenMinStringMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinStringMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinStringMapStruct{
		Field: map[string]string{"a": "1", "b": "2"},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinIntMap(b *testing.B) {
	data := &ValidGenMinIntMapStruct{
		Field: map[int]int{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMinIntMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinIntMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinIntMapStruct{
		Field: map[int]int{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinInt8Map(b *testing.B) {
	data := &ValidGenMinInt8MapStruct{
		Field: map[int8]int8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMinInt8MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinInt8Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinInt8MapStruct{
		Field: map[int8]int8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinInt16Map(b *testing.B) {
	data := &ValidGenMinInt16MapStruct{
		Field: map[int16]int16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMinInt16MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinInt16Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinInt16MapStruct{
		Field: map[int16]int16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinInt32Map(b *testing.B) {
	data := &ValidGenMinInt32MapStruct{
		Field: map[int32]int32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMinInt32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinInt32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinInt32MapStruct{
		Field: map[int32]int32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinInt64Map(b *testing.B) {
	data := &ValidGenMinInt64MapStruct{
		Field: map[int64]int64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMinInt64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinInt64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinInt64MapStruct{
		Field: map[int64]int64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinUintMap(b *testing.B) {
	data := &ValidGenMinUintMapStruct{
		Field: map[uint]uint{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMinUintMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinUintMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinUintMapStruct{
		Field: map[uint]uint{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinUint8Map(b *testing.B) {
	data := &ValidGenMinUint8MapStruct{
		Field: map[uint8]uint8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMinUint8MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinUint8Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinUint8MapStruct{
		Field: map[uint8]uint8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinUint16Map(b *testing.B) {
	data := &ValidGenMinUint16MapStruct{
		Field: map[uint16]uint16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMinUint16MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinUint16Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinUint16MapStruct{
		Field: map[uint16]uint16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinUint32Map(b *testing.B) {
	data := &ValidGenMinUint32MapStruct{
		Field: map[uint32]uint32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMinUint32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinUint32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinUint32MapStruct{
		Field: map[uint32]uint32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinUint64Map(b *testing.B) {
	data := &ValidGenMinUint64MapStruct{
		Field: map[uint64]uint64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMinUint64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinUint64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinUint64MapStruct{
		Field: map[uint64]uint64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinFloat32Map(b *testing.B) {
	data := &ValidGenMinFloat32MapStruct{
		Field: map[float32]float32{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := ValidGenMinFloat32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinFloat32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinFloat32MapStruct{
		Field: map[float32]float32{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinFloat64Map(b *testing.B) {
	data := &ValidGenMinFloat64MapStruct{
		Field: map[float64]float64{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := ValidGenMinFloat64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinFloat64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinFloat64MapStruct{
		Field: map[float64]float64{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMinBoolMap(b *testing.B) {
	data := &ValidGenMinBoolMapStruct{
		Field: map[bool]bool{true: true, false: false},
	}

	for b.Loop() {
		if err := ValidGenMinBoolMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMinBoolMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMinBoolMapStruct{
		Field: map[bool]bool{true: true, false: false},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxString(b *testing.B) {
	data := &ValidGenMaxStringStruct{
		Field: "abc",
	}

	for b.Loop() {
		if err := ValidGenMaxStringStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxString(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxStringStruct{
		Field: "abc",
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxStringSlice(b *testing.B) {
	data := &ValidGenMaxStringSliceStruct{
		Field: []string{"abc", "def"},
	}

	for b.Loop() {
		if err := ValidGenMaxStringSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxStringSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxStringSliceStruct{
		Field: []string{"abc", "def"},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxIntSlice(b *testing.B) {
	data := &ValidGenMaxIntSliceStruct{
		Field: []int{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMaxIntSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxIntSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxIntSliceStruct{
		Field: []int{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxInt8Slice(b *testing.B) {
	data := &ValidGenMaxInt8SliceStruct{
		Field: []int8{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMaxInt8SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxInt8Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxInt8SliceStruct{
		Field: []int8{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxInt16Slice(b *testing.B) {
	data := &ValidGenMaxInt16SliceStruct{
		Field: []int16{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMaxInt16SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxInt16Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxInt16SliceStruct{
		Field: []int16{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxInt32Slice(b *testing.B) {
	data := &ValidGenMaxInt32SliceStruct{
		Field: []int32{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMaxInt32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxInt32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxInt32SliceStruct{
		Field: []int32{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxInt64Slice(b *testing.B) {
	data := &ValidGenMaxInt64SliceStruct{
		Field: []int64{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMaxInt64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxInt64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxInt64SliceStruct{
		Field: []int64{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxUintSlice(b *testing.B) {
	data := &ValidGenMaxUintSliceStruct{
		Field: []uint{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMaxUintSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxUintSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxUintSliceStruct{
		Field: []uint{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxUint8Slice(b *testing.B) {
	data := &ValidGenMaxUint8SliceStruct{
		Field: []uint8{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMaxUint8SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxUint8Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxUint8SliceStruct{
		Field: []uint8{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxUint16Slice(b *testing.B) {
	data := &ValidGenMaxUint16SliceStruct{
		Field: []uint16{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMaxUint16SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxUint16Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxUint16SliceStruct{
		Field: []uint16{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxUint32Slice(b *testing.B) {
	data := &ValidGenMaxUint32SliceStruct{
		Field: []uint32{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMaxUint32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxUint32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxUint32SliceStruct{
		Field: []uint32{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxUint64Slice(b *testing.B) {
	data := &ValidGenMaxUint64SliceStruct{
		Field: []uint64{65, 67},
	}

	for b.Loop() {
		if err := ValidGenMaxUint64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxUint64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxUint64SliceStruct{
		Field: []uint64{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxFloat32Slice(b *testing.B) {
	data := &ValidGenMaxFloat32SliceStruct{
		Field: []float32{65.65, 67.67},
	}

	for b.Loop() {
		if err := ValidGenMaxFloat32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxFloat32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxFloat32SliceStruct{
		Field: []float32{65.65, 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxFloat64Slice(b *testing.B) {
	data := &ValidGenMaxFloat64SliceStruct{
		Field: []float64{65.65, 67.67},
	}

	for b.Loop() {
		if err := ValidGenMaxFloat64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxFloat64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxFloat64SliceStruct{
		Field: []float64{65.65, 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxBoolSlice(b *testing.B) {
	data := &ValidGenMaxBoolSliceStruct{
		Field: []bool{true, false},
	}

	for b.Loop() {
		if err := ValidGenMaxBoolSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxBoolSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxBoolSliceStruct{
		Field: []bool{true, false},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxStringMap(b *testing.B) {
	data := &ValidGenMaxStringMapStruct{
		Field: map[string]string{"a": "1", "b": "2"},
	}

	for b.Loop() {
		if err := ValidGenMaxStringMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxStringMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxStringMapStruct{
		Field: map[string]string{"a": "1", "b": "2"},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxIntMap(b *testing.B) {
	data := &ValidGenMaxIntMapStruct{
		Field: map[int]int{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMaxIntMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxIntMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxIntMapStruct{
		Field: map[int]int{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxInt8Map(b *testing.B) {
	data := &ValidGenMaxInt8MapStruct{
		Field: map[int8]int8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMaxInt8MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxInt8Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxInt8MapStruct{
		Field: map[int8]int8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxInt16Map(b *testing.B) {
	data := &ValidGenMaxInt16MapStruct{
		Field: map[int16]int16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMaxInt16MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxInt16Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxInt16MapStruct{
		Field: map[int16]int16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxInt32Map(b *testing.B) {
	data := &ValidGenMaxInt32MapStruct{
		Field: map[int32]int32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMaxInt32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxInt32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxInt32MapStruct{
		Field: map[int32]int32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxInt64Map(b *testing.B) {
	data := &ValidGenMaxInt64MapStruct{
		Field: map[int64]int64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMaxInt64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxInt64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxInt64MapStruct{
		Field: map[int64]int64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxUintMap(b *testing.B) {
	data := &ValidGenMaxUintMapStruct{
		Field: map[uint]uint{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMaxUintMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxUintMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxUintMapStruct{
		Field: map[uint]uint{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxUint8Map(b *testing.B) {
	data := &ValidGenMaxUint8MapStruct{
		Field: map[uint8]uint8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMaxUint8MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxUint8Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxUint8MapStruct{
		Field: map[uint8]uint8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxUint16Map(b *testing.B) {
	data := &ValidGenMaxUint16MapStruct{
		Field: map[uint16]uint16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMaxUint16MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxUint16Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxUint16MapStruct{
		Field: map[uint16]uint16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxUint32Map(b *testing.B) {
	data := &ValidGenMaxUint32MapStruct{
		Field: map[uint32]uint32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMaxUint32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxUint32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxUint32MapStruct{
		Field: map[uint32]uint32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxUint64Map(b *testing.B) {
	data := &ValidGenMaxUint64MapStruct{
		Field: map[uint64]uint64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenMaxUint64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxUint64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxUint64MapStruct{
		Field: map[uint64]uint64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxFloat32Map(b *testing.B) {
	data := &ValidGenMaxFloat32MapStruct{
		Field: map[float32]float32{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := ValidGenMaxFloat32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxFloat32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxFloat32MapStruct{
		Field: map[float32]float32{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxFloat64Map(b *testing.B) {
	data := &ValidGenMaxFloat64MapStruct{
		Field: map[float64]float64{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := ValidGenMaxFloat64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxFloat64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxFloat64MapStruct{
		Field: map[float64]float64{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenMaxBoolMap(b *testing.B) {
	data := &ValidGenMaxBoolMapStruct{
		Field: map[bool]bool{true: true},
	}

	for b.Loop() {
		if err := ValidGenMaxBoolMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorMaxBoolMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorMaxBoolMapStruct{
		Field: map[bool]bool{true: true},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenEq_ignore_caseString(b *testing.B) {
	data := &ValidGenEq_ignore_caseStringStruct{
		Field: "AbCdE",
	}

	for b.Loop() {
		if err := ValidGenEq_ignore_caseStringStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorEq_ignore_caseString(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorEq_ignore_caseStringStruct{
		Field: "AbCdE",
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenNeq_ignore_caseString(b *testing.B) {
	data := &ValidGenNeq_ignore_caseStringStruct{
		Field: "a1b2c3",
	}

	for b.Loop() {
		if err := ValidGenNeq_ignore_caseStringStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorNeq_ignore_caseString(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorNeq_ignore_caseStringStruct{
		Field: "a1b2c3",
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenString(b *testing.B) {
	data := &ValidGenLenStringStruct{
		Field: "ab",
	}

	for b.Loop() {
		if err := ValidGenLenStringStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenString(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenStringStruct{
		Field: "ab",
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenStringSlice(b *testing.B) {
	data := &ValidGenLenStringSliceStruct{
		Field: []string{"abc", "def"},
	}

	for b.Loop() {
		if err := ValidGenLenStringSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenStringSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenStringSliceStruct{
		Field: []string{"abc", "def"},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenIntSlice(b *testing.B) {
	data := &ValidGenLenIntSliceStruct{
		Field: []int{65, 67},
	}

	for b.Loop() {
		if err := ValidGenLenIntSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenIntSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenIntSliceStruct{
		Field: []int{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenInt8Slice(b *testing.B) {
	data := &ValidGenLenInt8SliceStruct{
		Field: []int8{65, 67},
	}

	for b.Loop() {
		if err := ValidGenLenInt8SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenInt8Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenInt8SliceStruct{
		Field: []int8{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenInt16Slice(b *testing.B) {
	data := &ValidGenLenInt16SliceStruct{
		Field: []int16{65, 67},
	}

	for b.Loop() {
		if err := ValidGenLenInt16SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenInt16Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenInt16SliceStruct{
		Field: []int16{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenInt32Slice(b *testing.B) {
	data := &ValidGenLenInt32SliceStruct{
		Field: []int32{65, 67},
	}

	for b.Loop() {
		if err := ValidGenLenInt32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenInt32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenInt32SliceStruct{
		Field: []int32{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenInt64Slice(b *testing.B) {
	data := &ValidGenLenInt64SliceStruct{
		Field: []int64{65, 67},
	}

	for b.Loop() {
		if err := ValidGenLenInt64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenInt64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenInt64SliceStruct{
		Field: []int64{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenUintSlice(b *testing.B) {
	data := &ValidGenLenUintSliceStruct{
		Field: []uint{65, 67},
	}

	for b.Loop() {
		if err := ValidGenLenUintSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenUintSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenUintSliceStruct{
		Field: []uint{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenUint8Slice(b *testing.B) {
	data := &ValidGenLenUint8SliceStruct{
		Field: []uint8{65, 67},
	}

	for b.Loop() {
		if err := ValidGenLenUint8SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenUint8Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenUint8SliceStruct{
		Field: []uint8{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenUint16Slice(b *testing.B) {
	data := &ValidGenLenUint16SliceStruct{
		Field: []uint16{65, 67},
	}

	for b.Loop() {
		if err := ValidGenLenUint16SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenUint16Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenUint16SliceStruct{
		Field: []uint16{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenUint32Slice(b *testing.B) {
	data := &ValidGenLenUint32SliceStruct{
		Field: []uint32{65, 67},
	}

	for b.Loop() {
		if err := ValidGenLenUint32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenUint32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenUint32SliceStruct{
		Field: []uint32{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenUint64Slice(b *testing.B) {
	data := &ValidGenLenUint64SliceStruct{
		Field: []uint64{65, 67},
	}

	for b.Loop() {
		if err := ValidGenLenUint64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenUint64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenUint64SliceStruct{
		Field: []uint64{65, 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenFloat32Slice(b *testing.B) {
	data := &ValidGenLenFloat32SliceStruct{
		Field: []float32{65.65, 67.67},
	}

	for b.Loop() {
		if err := ValidGenLenFloat32SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenFloat32Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenFloat32SliceStruct{
		Field: []float32{65.65, 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenFloat64Slice(b *testing.B) {
	data := &ValidGenLenFloat64SliceStruct{
		Field: []float64{65.65, 67.67},
	}

	for b.Loop() {
		if err := ValidGenLenFloat64SliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenFloat64Slice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenFloat64SliceStruct{
		Field: []float64{65.65, 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenBoolSlice(b *testing.B) {
	data := &ValidGenLenBoolSliceStruct{
		Field: []bool{true, false},
	}

	for b.Loop() {
		if err := ValidGenLenBoolSliceStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenBoolSlice(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenBoolSliceStruct{
		Field: []bool{true, false},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenStringMap(b *testing.B) {
	data := &ValidGenLenStringMapStruct{
		Field: map[string]string{"a": "1", "b": "2"},
	}

	for b.Loop() {
		if err := ValidGenLenStringMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenStringMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenStringMapStruct{
		Field: map[string]string{"a": "1", "b": "2"},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenIntMap(b *testing.B) {
	data := &ValidGenLenIntMapStruct{
		Field: map[int]int{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenLenIntMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenIntMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenIntMapStruct{
		Field: map[int]int{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenInt8Map(b *testing.B) {
	data := &ValidGenLenInt8MapStruct{
		Field: map[int8]int8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenLenInt8MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenInt8Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenInt8MapStruct{
		Field: map[int8]int8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenInt16Map(b *testing.B) {
	data := &ValidGenLenInt16MapStruct{
		Field: map[int16]int16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenLenInt16MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenInt16Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenInt16MapStruct{
		Field: map[int16]int16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenInt32Map(b *testing.B) {
	data := &ValidGenLenInt32MapStruct{
		Field: map[int32]int32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenLenInt32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenInt32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenInt32MapStruct{
		Field: map[int32]int32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenInt64Map(b *testing.B) {
	data := &ValidGenLenInt64MapStruct{
		Field: map[int64]int64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenLenInt64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenInt64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenInt64MapStruct{
		Field: map[int64]int64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenUintMap(b *testing.B) {
	data := &ValidGenLenUintMapStruct{
		Field: map[uint]uint{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenLenUintMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenUintMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenUintMapStruct{
		Field: map[uint]uint{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenUint8Map(b *testing.B) {
	data := &ValidGenLenUint8MapStruct{
		Field: map[uint8]uint8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenLenUint8MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenUint8Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenUint8MapStruct{
		Field: map[uint8]uint8{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenUint16Map(b *testing.B) {
	data := &ValidGenLenUint16MapStruct{
		Field: map[uint16]uint16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenLenUint16MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenUint16Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenUint16MapStruct{
		Field: map[uint16]uint16{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenUint32Map(b *testing.B) {
	data := &ValidGenLenUint32MapStruct{
		Field: map[uint32]uint32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenLenUint32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenUint32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenUint32MapStruct{
		Field: map[uint32]uint32{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenUint64Map(b *testing.B) {
	data := &ValidGenLenUint64MapStruct{
		Field: map[uint64]uint64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := ValidGenLenUint64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenUint64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenUint64MapStruct{
		Field: map[uint64]uint64{1: 65, 2: 67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenFloat32Map(b *testing.B) {
	data := &ValidGenLenFloat32MapStruct{
		Field: map[float32]float32{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := ValidGenLenFloat32MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenFloat32Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenFloat32MapStruct{
		Field: map[float32]float32{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenFloat64Map(b *testing.B) {
	data := &ValidGenLenFloat64MapStruct{
		Field: map[float64]float64{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := ValidGenLenFloat64MapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenFloat64Map(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenFloat64MapStruct{
		Field: map[float64]float64{1: 65.65, 2: 67.67},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenLenBoolMap(b *testing.B) {
	data := &ValidGenLenBoolMapStruct{
		Field: map[bool]bool{true: true, false: false},
	}

	for b.Loop() {
		if err := ValidGenLenBoolMapStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorLenBoolMap(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorLenBoolMapStruct{
		Field: map[bool]bool{true: true, false: false},
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInString(b *testing.B) {
	data := &ValidGenInStringStruct{
		Field: "cd",
	}

	for b.Loop() {
		if err := ValidGenInStringStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInString(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInStringStruct{
		Field: "cd",
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInInt(b *testing.B) {
	data := &ValidGenInIntStruct{
		Field: 34,
	}

	for b.Loop() {
		if err := ValidGenInIntStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInInt(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInIntStruct{
		Field: 34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInInt8(b *testing.B) {
	data := &ValidGenInInt8Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := ValidGenInInt8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInInt8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInInt8Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInInt16(b *testing.B) {
	data := &ValidGenInInt16Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := ValidGenInInt16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInInt16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInInt16Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInInt32(b *testing.B) {
	data := &ValidGenInInt32Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := ValidGenInInt32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInInt32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInInt32Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInInt64(b *testing.B) {
	data := &ValidGenInInt64Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := ValidGenInInt64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInInt64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInInt64Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInUint(b *testing.B) {
	data := &ValidGenInUintStruct{
		Field: 34,
	}

	for b.Loop() {
		if err := ValidGenInUintStructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInUint(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInUintStruct{
		Field: 34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInUint8(b *testing.B) {
	data := &ValidGenInUint8Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := ValidGenInUint8StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInUint8(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInUint8Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInUint16(b *testing.B) {
	data := &ValidGenInUint16Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := ValidGenInUint16StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInUint16(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInUint16Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInUint32(b *testing.B) {
	data := &ValidGenInUint32Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := ValidGenInUint32StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInUint32(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInUint32Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}

func BenchmarkValidGenInUint64(b *testing.B) {
	data := &ValidGenInUint64Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := ValidGenInUint64StructValidate(data); len(err) > 0 {
			b.FailNow()
		}
	}
}

func BenchmarkValidatorInUint64(b *testing.B) {
	var validate *validator.Validate

	validate = validator.New(validator.WithRequiredStructEnabled())
	data := &ValidatorInUint64Struct{
		Field: 34,
	}

	for b.Loop() {
		if err := validate.Struct(data); err != nil {
			b.FailNow()
		}
	}
}
