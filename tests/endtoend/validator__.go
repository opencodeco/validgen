// Code generated by ValidGen. DO NOT EDIT.

package main

import (
	"github.com/opencodeco/validgen/tests/endtoend/structsinpkg"
	"github.com/opencodeco/validgen/types"
)

func AddressValidate(obj *Address) []error {
	var errs []error
	if !(obj.Street != "") {
		errs = append(errs, types.NewValidationError("Street is required"))
	}
	if !(obj.City != "") {
		errs = append(errs, types.NewValidationError("City is required"))
	}
	return errs
}
func AllTypes1Validate(obj *AllTypes1) []error {
	var errs []error
	if !(obj.FirstName != "") {
		errs = append(errs, types.NewValidationError("FirstName is required"))
	}
	if !(obj.LastName != "") {
		errs = append(errs, types.NewValidationError("LastName is required"))
	}
	if !(obj.Age != 0) {
		errs = append(errs, types.NewValidationError("Age is required"))
	}
	return errs
}
func AllTypes2Validate(obj *AllTypes2) []error {
	var errs []error
	if !(obj.FirstName != "") {
		errs = append(errs, types.NewValidationError("FirstName is required"))
	}
	if !(obj.LastName != "") {
		errs = append(errs, types.NewValidationError("LastName is required"))
	}
	if !(obj.Age >= 18) {
		errs = append(errs, types.NewValidationError("Age must be >= 18"))
	}
	if !(obj.Age <= 130) {
		errs = append(errs, types.NewValidationError("Age must be <= 130"))
	}
	if !(len(obj.UserName) >= 5) {
		errs = append(errs, types.NewValidationError("UserName length must be >= 5"))
	}
	if !(len(obj.UserName) <= 10) {
		errs = append(errs, types.NewValidationError("UserName length must be <= 10"))
	}
	return errs
}
func ArrayStringValidate(obj *ArrayString) []error {
	var errs []error
	if !(types.SliceOnlyContains(obj.TypesIn[:], []string{"a", "b", "c"})) {
		errs = append(errs, types.NewValidationError("TypesIn elements must be one of 'a' 'b' 'c'"))
	}
	if !(types.SliceNotContains(obj.TypesNotIn[:], []string{"a", "b", "c"})) {
		errs = append(errs, types.NewValidationError("TypesNotIn elements must not be one of 'a' 'b' 'c'"))
	}
	return errs
}
func CmpInnerStringFieldsValidate(obj *CmpInnerStringFields) []error {
	var errs []error
	if !(obj.Field2eq1 == obj.Field1) {
		errs = append(errs, types.NewValidationError("Field2eq1 must be equal to Field1"))
	}
	if !(obj.Field3neq1 != obj.Field1) {
		errs = append(errs, types.NewValidationError("Field3neq1 must not be equal to Field1"))
	}
	return errs
}
func CmpInnerUint8FieldsValidate(obj *CmpInnerUint8Fields) []error {
	var errs []error
	if !(obj.Field2eq1 == obj.Field1) {
		errs = append(errs, types.NewValidationError("Field2eq1 must be equal to Field1"))
	}
	if !(obj.Field3neq1 != obj.Field1) {
		errs = append(errs, types.NewValidationError("Field3neq1 must not be equal to Field1"))
	}
	if !(obj.Field5gte4 >= obj.Field4) {
		errs = append(errs, types.NewValidationError("Field5gte4 must be >= Field4"))
	}
	if !(obj.Field6gt4 > obj.Field4) {
		errs = append(errs, types.NewValidationError("Field6gt4 must be > Field4"))
	}
	if !(obj.Field7lte4 <= obj.Field4) {
		errs = append(errs, types.NewValidationError("Field7lte4 must be <= Field4"))
	}
	if !(obj.Field8lt4 < obj.Field4) {
		errs = append(errs, types.NewValidationError("Field8lt4 must be < Field4"))
	}
	return errs
}
func CmpNestedStringFieldsValidate(obj *CmpNestedStringFields) []error {
	var errs []error
	if !(obj.Field1eqNestedField1 == obj.Nested.Field1) {
		errs = append(errs, types.NewValidationError("Field1eqNestedField1 must be equal to Nested.Field1"))
	}
	if !(obj.Field2neqNestedField1 != obj.Nested.Field1) {
		errs = append(errs, types.NewValidationError("Field2neqNestedField1 must not be equal to Nested.Field1"))
	}
	return errs
}
func CmpNestedUint8FieldsValidate(obj *CmpNestedUint8Fields) []error {
	var errs []error
	if !(obj.Field1eqNestedField1 == obj.Nested.Field1) {
		errs = append(errs, types.NewValidationError("Field1eqNestedField1 must be equal to Nested.Field1"))
	}
	if !(obj.Field2neqNestedField1 != obj.Nested.Field1) {
		errs = append(errs, types.NewValidationError("Field2neqNestedField1 must not be equal to Nested.Field1"))
	}
	if !(obj.Field3gteNestedField2 >= obj.Nested.Field2) {
		errs = append(errs, types.NewValidationError("Field3gteNestedField2 must be >= Nested.Field2"))
	}
	if !(obj.Field4gtNestedField2 > obj.Nested.Field2) {
		errs = append(errs, types.NewValidationError("Field4gtNestedField2 must be > Nested.Field2"))
	}
	if !(obj.Field5lteNestedField2 <= obj.Nested.Field2) {
		errs = append(errs, types.NewValidationError("Field5lteNestedField2 must be <= Nested.Field2"))
	}
	if !(obj.Field6ltNestedField2 < obj.Nested.Field2) {
		errs = append(errs, types.NewValidationError("Field6ltNestedField2 must be < Nested.Field2"))
	}
	return errs
}
func SliceStringValidate(obj *SliceString) []error {
	var errs []error
	if !(len(obj.TypesRequired) != 0) {
		errs = append(errs, types.NewValidationError("TypesRequired must not be empty"))
	}
	if !(len(obj.TypesMin) >= 2) {
		errs = append(errs, types.NewValidationError("TypesMin must have at least 2 elements"))
	}
	if !(len(obj.TypesMax) <= 5) {
		errs = append(errs, types.NewValidationError("TypesMax must have at most 5 elements"))
	}
	if !(len(obj.TypesLen) == 3) {
		errs = append(errs, types.NewValidationError("TypesLen must have exactly 3 elements"))
	}
	if !(types.SliceOnlyContains(obj.TypesIn, []string{"a", "b", "c"})) {
		errs = append(errs, types.NewValidationError("TypesIn elements must be one of 'a' 'b' 'c'"))
	}
	if !(types.SliceNotContains(obj.TypesNotIn, []string{"a", "b", "c"})) {
		errs = append(errs, types.NewValidationError("TypesNotIn elements must not be one of 'a' 'b' 'c'"))
	}
	return errs
}
func StringTypeValidate(obj *StringType) []error {
	var errs []error
	if !(obj.FieldReq != "") {
		errs = append(errs, types.NewValidationError("FieldReq is required"))
	}
	if !(obj.FieldEq == "aabbcc") {
		errs = append(errs, types.NewValidationError("FieldEq must be equal to 'aabbcc'"))
	}
	if !(types.EqualFold(obj.FieldEqIC, "yes")) {
		errs = append(errs, types.NewValidationError("FieldEqIC must be equal to 'yes'"))
	}
	if !(len(obj.FieldMinMax) >= 5) {
		errs = append(errs, types.NewValidationError("FieldMinMax length must be >= 5"))
	}
	if !(len(obj.FieldMinMax) <= 10) {
		errs = append(errs, types.NewValidationError("FieldMinMax length must be <= 10"))
	}
	if !(len(obj.FieldLen) == 8) {
		errs = append(errs, types.NewValidationError("FieldLen length must be 8"))
	}
	if !(obj.FieldNeq != "cba") {
		errs = append(errs, types.NewValidationError("FieldNeq must not be equal to 'cba'"))
	}
	if !(!types.EqualFold(obj.FieldNeqIC, "yes")) {
		errs = append(errs, types.NewValidationError("FieldNeqIC must not be equal to 'yes'"))
	}
	if !(obj.FieldIn == "ab" || obj.FieldIn == "bc" || obj.FieldIn == "cd") {
		errs = append(errs, types.NewValidationError("FieldIn must be one of 'ab' 'bc' 'cd'"))
	}
	if !(obj.FieldNotIn != "xx" && obj.FieldNotIn != "yy" && obj.FieldNotIn != "zz") {
		errs = append(errs, types.NewValidationError("FieldNotIn must not be one of 'xx' 'yy' 'zz'"))
	}
	if !(obj.EmailReq != "") {
		errs = append(errs, types.NewValidationError("EmailReq is required"))
	}
	if !(types.IsValidEmail(obj.EmailReq)) {
		errs = append(errs, types.NewValidationError("EmailReq must be a valid email"))
	}
	if !(types.IsValidEmail(obj.EmailOpt)) {
		errs = append(errs, types.NewValidationError("EmailOpt must be a valid email"))
	}
	return errs
}
func UserValidate(obj *User) []error {
	var errs []error
	if !(obj.FirstName != "") {
		errs = append(errs, types.NewValidationError("FirstName is required"))
	}
	if !(obj.Age >= 18) {
		errs = append(errs, types.NewValidationError("Age must be >= 18"))
	}
	if !(obj.Age <= 130) {
		errs = append(errs, types.NewValidationError("Age must be <= 130"))
	}
	errs = append(errs, AddressValidate(&obj.Address)...)
	return errs
}
func UserWithStructInPkgValidate(obj *UserWithStructInPkg) []error {
	var errs []error
	if !(obj.FirstName != "") {
		errs = append(errs, types.NewValidationError("FirstName is required"))
	}
	if !(obj.Age >= 18) {
		errs = append(errs, types.NewValidationError("Age must be >= 18"))
	}
	if !(obj.Age <= 130) {
		errs = append(errs, types.NewValidationError("Age must be <= 130"))
	}
	errs = append(errs, structsinpkg.AddressValidate(&obj.Address)...)
	return errs
}
